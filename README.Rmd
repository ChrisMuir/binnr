---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "plots/README-"
)
```

## What is `binner`?
`binnr` is a package that creates, manages, and applies simple binning
transformations.

## Usage
The easiest way to use `binnr` is with the `bin.data` function. When applied to 
a `data.frame`, `bin.data` creates a `bin` object for every variable and stores
the information necessary to apply a weight-of-evidence (WoE) substitution. Why
is this beneficial? Data is often not well-behaved or continuous. Variables can 
have exception values, missing values, or monotonic relationships that need to
be enforced. `binnr` accomodates all of these situations and further enables the
modeler to tweak variable transformations to their liking.

## Examples
We will use the titanic dataset that can be found in the `mjollnir` package for
all of the examples in this walkthrough.

```{r, echo = TRUE}
data(titanic, package='mjollnir')
head(titanic)
```

Inspecting the columns, we can see that this dataset encompases a variety
of data types: numeric & character, continuous & discrete. We can "class" these
variables by calling the `bin.data` function on this dataset and storing in
an object called `bins`:

```{r, echo = TRUE, eval=TRUE, results='hide'}
bins <- bin.data(titanic[,-1], titanic$Survived)
```

This stores all of the bin transformations in a list called `bins` that can be
accessed using standard R `$` indexing. The default action when typing a binned
variable and pressing `<enter>` is to display a WoE table:

```{r, echo = TRUE, tidy=TRUE}
bins$Age
```

But it can also be plotted by calling the `plot` function on the binned variable:
```{r, echo = TRUE, fig.height=4, fig.width=12}
plot(bins$Age)
```

The y-axis displays the bin ranges for all of the plots. The first plot shows
bin counts, the second shows bin WoE, and the third shows bin probability of the
1-class for the dependent variable. The red line is the overall mean.

## `bin.data` options

### `mono`
The WoE  pattern for this varibale flips alot. A monotonic replationship can be
enforced by passing a mono argument to the bin.data function like so:

```{r, echo = TRUE, eval=TRUE, results='hide'}
bins <- bin.data(titanic[,-1], titanic$Survived, mono = c(Age=-1))
```

```{r, echo = TRUE, fig.height=3, fig.width=12}
plot(bins$Age)
```

Notice that a named vector of the form `c(VAR=MONO)` is passed in to the `mono`
argument. A global default may be passed in using the name `ALL`. `mono` can
take on the following values: `{-1, 0, 1}`. The monotonic relationship assumes
that the 1-class of the dependent variable is the target. Therefore a `-1` value
represents a target variable that decreases in likelihood as the independent
variable increases whereas a `1` value indicates an increases in the likelihood
of the target variable as the dependent variable increases.

### `exception`

It is not uncommon to have special values that should be considered valid for
binning. In such cases we wish to hold them out from the binning process yet
still use them for purposes of calculating information value. The `exception`
argument takes a named list of values that should be excluded from binning:

```{r, echo = TRUE, eval=TRUE, results='hide'}
bins <- bin.data(titanic[,-1], titanic$Survived, exceptions = list(SibSp=c(0,1)))
```
```{r, echo = TRUE, fig.height=3, fig.width=12}
plot(bins$SibSp)
```

Notice that 0s and 1s are now on their own levels below the binned continuous
values. 

### `min.iv`

The binning algorithm uses information value to break continuous variables into 
bins. The algorithm will only create a split if the resulting bins increase the 
overall variable information value by some value specified by `min.iv`. Larger
values will result in fewer bins.

```{r, echo = TRUE, eval=TRUE, results='hide'}
bins <- bin.data(titanic[,-1], titanic$Survived, min.iv=0, mono=c(Age=-1))
```
```{r, echo = TRUE, fig.height=3, fig.width=12}
plot(bins$Age)
```

### `min.cnt` & `max.bin`

`bin.data` can also be passed values controlling the size of resulting bins as
well as the maximum number of bins achieved. The default value for the `min.cnt`
is the square root of the number of observations. This generally results in 
adequate counts for the final binning scheme.

## Modyfing bins

`binnr` provides a number of convenience functions to expand, collapse, and
neutralize bin levels. The results are different for continuous and discrete
variables.

### Collapsing Bins

Continuous variables can only collapse adjacent bins. Discrete variables may
collapse non-adjacent bins. By default, `binnr` treats factors as discrete and
numeric variabls as continuous. To collapse bins, simply use the minus, `-`,
sign followed by a vector of the bin levels to collapse:

```{r, echo = TRUE, fig.height=3, fig.width=12}
plot(bins$Fare)
plot(bins$Fare - 2:5)
```

Discrete bins can also be collapsed using the same notation:

```{r, echo = TRUE, fig.height=3, fig.width=12}
plot(bins$Embarked)
plot(bins$Embarked - 1:3)
```





